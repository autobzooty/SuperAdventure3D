class GameSetupEvent : ZilchEvent
{
  sends CustomGameSetup : GameSetupEvent;
}

class InputMappingEvent : ZilchEvent
{
  sends InputMappingRequest : InputMappingEvent;
  sends InputMappingSetup : InputMappingEvent;
  
  var Sticks = HashMap[GameStick, Array[StickMapping]]();
  var Actions = HashMap[GameAction, Array[ActionMapping]]();
}

class RelationshipSetupEvent : ZilchEvent
{
  sends RelationshipSetupRequest : RelationshipSetupEvent;
}

class UpdateEventSends
{
  sends IMUpdate : UpdateEvent;
  
  sends ConsoleUpkeep : UpdateEvent;
  sends Upkeep : UpdateEvent;
  
  sends PlayerUpdate : UpdateEvent;
  sends StandardUpdate : UpdateEvent;
  
  sends CameraUpdate : UpdateEvent;
  sends GUIUpdate : UpdateEvent;
  sends PhysicsUpdate : UpdateEvent;
  
  sends Cleanup : UpdateEvent;
  
  sends IMCleanup : UpdateEvent;
}

class MWEvent : ZilchEvent
{
  var Instigator : Cog;
  var InstigatingFaction : FactionValue;
  var InstigatorName : String;
  
  constructor() : base() {}
  
  constructor(instigator : Cog) : base()
  {
    this.Instigator = instigator;
    this.InstigatingFaction = Faction.Find(instigator);
    this.InstigatorName = instigator.Name;
  }
  
  constructor(instigatingFaction : FactionValue) : base()
  {
    this.InstigatingFaction = instigatingFaction;
  }
}

class HealthEvent : MWEvent
{
  sends RequestDamage : HealthEvent;
  sends WasDamaged : HealthEvent;
  sends DidDamage : HealthEvent;
  sends RequestHeal : HealthEvent;
  sends WasHealed : HealthEvent;
  sends DidHeal : HealthEvent;
  sends WasDealtCritical : HealthEvent;
  sends DidDealCritical : HealthEvent;
  sends HPDepleted : HealthEvent;
  sends Death : HealthEvent;
  
  // the amount of the HP change. the effects of whether it's a crit are
  // already factored in. this number should always be positive: a
  // positive value in a Damage event indicates a negative HP change,
  // and a positive value in a Heal event indicates a positive HP change
  var Amount : Real;
  // whether this is a crit
  var Critical : Boolean;
  // whether this attack can be evaded
  var Evadable : Boolean;
  // what type this HP change is
  var Type : DamageType = DamageType.None;
  // whether factions should be ignored for this HP change
  var IgnoreFaction : Boolean = false;
  // whether invincibility should be ignored for this HP change
  var IgnoreInvincibility : Boolean = false;
  
  // where this health change occurred, if applicable
  var WorldPoint : Real3;
  // normal of the contact that caused this health change, if applicable
  var ContactNormal : Real3;
  
  // the cog that causes this HP change (e.g., the weapon used by a
  // player, etc.)
  var Deliverer : Cog;
  // the cog that receives this HP change (e.g., the foe struck by a
  // sword, etc.). generally speaking this is the Owner of the
  // Health component that is involved in this interaction
  var Receiver : Cog;
  
  // whether this event has been "intercepted" -- typically useful for
  // death-related stuff
  var Handled : Boolean = false;
  
  // whether death is being prevented for this HP change
  var PreventDeath : Boolean = false;
  
  // TODO:
  // 
  // results
  
  // the inter-faction relationship between the instigator and the
  // receiver
  var Relationship : Relationship
  {
    get
    {
      return Relationship.Get(this.InstigatingFaction, this.Receiver.Faction.AssignedFaction);
    }
  }
}

class EquipmentEvent : MWEvent
{
  sends ItemEquipped : EquipmentEvent;
  sends ItemUnequipped : EquipmentEvent;
  
  // TODO:
  // 
  // i strongly suspect that we'll want to differentiate between when an item is
  // equipped by a player during the game, like through the menu or whatever, and
  // when it is "equipped" on initialize, like when a character with equipment is
  // created or loaded. i think it's mostly going to be a matter of a difference
  // in feedback, but there could be mechanical implications as well, and it
  // would certainly be relevant for data tracking
  
  var Equipment : EquipmentBase;
  var StatBlock : StatBlock;
}
