class IM : ZilchComponent
{
  var Mode : InputMode = InputMode.Default;
  
  var Current : InputData = InputData();
  var Previous : InputData = InputData();
  
  var History : Array[InputData] = Array[InputData]();
  var HistoryIndex = 0;
  
  var GameStickToMappingList : HashMap[GameStick, Array[StickMapping]] =
    HashMap[GameStick, Array[StickMapping]]();
  var GameActionToMappingList : HashMap[GameAction, Array[ActionMapping]] =
    HashMap[GameAction, Array[ActionMapping]]();
  
  
  function Initialize(init : CogInitializer)
  {
    Zero.Connect(this.GameSession, Events.InputMappingSetup, this.OnInputMappingSetup);
    Zero.Connect(this.GameSession, Events.IMUpdate, this.OnIMUpdate);
    Zero.Connect(this.GameSession, Events.IMCleanup, this.OnIMCleanup);
  }
  
  
  function OnInputMappingSetup(event : InputMappingEvent)
  {
    this.GameStickToMappingList = event.Sticks;
    this.GameActionToMappingList = event.Actions;
  }
  
  
  function OnIMUpdate(event : UpdateEvent)
  {
    // TODO:
    // 
    // if the IM is updated by a space, then if that space is paused, the IM will
    // also be paused. this is bad because any other space that wants to get input,
    // like, say, a menu, is outta luck.
    // 
    // however, if i want to, say,  pause the game and step a frame at a time while
    // providing input, it's very difficult to carefully get my input to happen
    // exactly the way i want it just right while i'm frame-stepping. i need to
    // come up with a good way to be able to provide proper input while i'm frame
    // stepping and yet still have the input manager be unpaused for other spaces
    
    if (this.Mode == InputMode.Replay)
    {
      this.Current = this.GetReplayCurrent();
    }
    else
    {
      this.Current = InputData();
      
      this.RecordStickValues();
      this.RecordActionValues();
    }
  }
  
  
  function OnIMCleanup(event : UpdateEvent)
  {
    if (this.Mode == InputMode.Replay)
    {
      this.Previous = this.GetReplayPrevious();
      ++this.HistoryIndex;
    }
    else if (this.Mode == InputMode.Record)
    {
      this.History.Add(this.Current);
      
      this.Previous = this.Current.Copy();
    }
    else
    {
      this.Previous = this.Current.Copy();
    }
  }
  
  
  function RecordStickValues()
  {
    foreach (var entry in this.GameStickToMappingList)
    {
      var stick = entry.Key;
      var mappingList = entry.Value;
      
      foreach (var mapping in mappingList)
        this.Current.Sticks[stick] += mapping.GetValue();
    }
  }
  
  
  function RecordActionValues()
  {
    foreach (var entry in this.GameActionToMappingList)
    {
      var action = entry.Key;
      var mappingList = entry.Value;
      
      foreach (var mapping in mappingList)
        this.Current.Actions[action] = this.Current.Actions[action] || mapping.GetDown();
    }
  }
  
  
  function Down(action : GameAction) : Boolean
  {
    return this.Current.Actions[action];
  }
  
  function Up(action : GameAction) : Boolean
  {
    return !this.Current.Actions[action];
  }
  
  function Triggered(action : GameAction) : Boolean
  {
    return this.Current.Actions[action] && !this.Previous.Actions[action];
  }
  
  function Released(action : GameAction) : Boolean
  {
    return !this.Current.Actions[action] && this.Previous.Actions[action];
  }
  
  function GetStick(stick : GameStick) : Real2
  {
    return this.Current.Sticks[stick];
  }
  
  
  function GetStickPrev(stick : GameStick) : Real2
  {
    return this.Previous.Sticks[stick];
  }
  
  
  function GetReplayCurrent() : InputData
  {
    return this.History[this.HistoryIndex];
  }
  
  
  function GetReplayPrevious() : InputData
  {
    if (this.HistoryIndex > 0)
      return this.History[this.HistoryIndex - 1];
    else
      return this.History[0];
  }
}


class InputData
{
  var Sticks : Array[Real2] = Array[Real2](GameStick.COUNT_ + 1);
  var Actions : Array[Boolean] = Array[Boolean](GameAction.COUNT_ + 1);
  
  function Copy() : InputData
  {
    return InputData()
    {
      Sticks  = this.Sticks.Copy(),
      Actions = this.Actions.Copy(),
    };
  }
}


enum InputMode
{
  Default,
  Record,
  Replay,
}


enum GameStick
{
  Move,
  Camera,
  Zoom,
  MenuNav,
  
  COUNT_
}


enum GameAction
{
  Jump,
  Trick,
  Attack,
  Interact,
  Menu,
  NavRight,
  NavUp,
  NavLeft,
  NavDown,
  
  COUNT_
}
