///////////////////////////////////////////////////////////////////////////////
///           |
/// AUTHORS   | Alek Hiebert
/// COPYRIGHT | (C) 2018 Milky Way Games
///           |
///////////////////////////////////////////////////////////////////////////////

class StandardMover : ZilchComponent
{
  [Dependency]
  var RigidBody : RigidBody;
  [Dependency]
  var Transform : Transform;
  [Dependency]
  var Orientation : Orientation;
  var IM : IM;
  var MoverSpeed : Real = 0;
  [Property]
  var Acceleration : Real = 50;
  [Property]
  var Deceleration : Real = 100;
  [Property]
  var TurnSpeed : Real = 10;
  var RequestedMoveDirection : Real3;
  [Property]
  var MinimumStickThreshold : Real = 0.2;
  [Property]
  var BaseMaxSpeed : Real = 1000;
  var OnGround : Boolean = true;
  [Property]
  var GravityStrength : Real = -10;
  
  //***************************************************************************
  function Initialize(init : CogInitializer)
  {
    this.IM = this.GameSession.IM;
    Zero.Connect(this.Owner, Events.MovementRequest, this.OnMovementRequest);
    Zero.Connect(this.Space, Events.PhysicsUpdate, this.OnPhysicsUpdate);
  }
  
  //***************************************************************************
  function OnMovementRequest(event : InputEvent)
  {
    this.MoverSpeed += this.Acceleration * event.Magnitude * event.Dt;
    if(event.Magnitude >= this.MinimumStickThreshold)
    {
      this.RequestedMoveDirection = event.RequestedMoveDirection;
    }
    else
    {
      if(this.MoverSpeed >= this.Deceleration * event.Dt)
      {
        this.MoverSpeed -= this.Deceleration * event.Dt;
      }
      else
      {
        this.MoverSpeed = 0;
      }
    }
    if(this.MoverSpeed > this.BaseMaxSpeed)
    {
      this.MoverSpeed = this.BaseMaxSpeed;
    }
    Print(this.MoverSpeed);
  }

  //***************************************************************************
  function OnPhysicsUpdate(event : UpdateEvent)
  {
    var newVelocity = this.Orientation.WorldForward * this.MoverSpeed * event.Dt;
    
    //Check collision on our feet to see if we're on the ground
    this.OnGround = false;
    var contacts = this.Owner.Collider.Contacts;
    foreach(var contactPoint in contacts)
    {
      if(contactPoint.FirstPoint.LocalPoint.Y < -0.44)
      {
        this.OnGround = true;
      }
    }
    //Apply gravity if we're not on the ground
    if(!this.OnGround)
    {
      newVelocity.Y += this.GravityStrength * event.Dt;
    }
    else
    {
      newVelocity.Y = 0;
    }
    //Final application of velocity to the rigidbody. ONLY DO THIS ONCE PER FRAME
    this.RigidBody.Velocity = newVelocity;
    this.UpdateOrientation();
    
    var newRot : Real3 = Math.RotateTowards(this.Orientation.WorldForward, this.RequestedMoveDirection, this.TurnSpeed * event.Dt);

    this.Owner.Orientation.LookAtDirection(newRot);
  }
  
  //***************************************************************************
  function UpdateOrientation()
  {
    var ray = Ray(this.Owner.Transform.Translation, Real3(0, -1, 0));
    var result = this.Space.PhysicsSpace.CastRayFirst(ray);
    this.Orientation.GlobalUp = result.Normal;
    Print(this.Orientation.WorldForward);
  }
}
