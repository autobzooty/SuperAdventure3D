///////////////////////////////////////////////////////////////////////////////
///           |
/// AUTHORS   | Alek Hiebert
/// COPYRIGHT | (C) 2018 Milky Way Games
///           |
///////////////////////////////////////////////////////////////////////////////

class StandardMover : ZilchComponent
{
  [Dependency]
  var RigidBody : RigidBody;
  [Dependency]
  var Transform : Transform;
  [Dependency]
  var Orientation : Orientation;
  var IM : IM;
  var MoverSpeed : Real = 0;
  [Property]
  var Acceleration : Real = 50;
  [Property]
  var Deceleration : Real = 100;
  [Property]
  var TurnSpeed : Real = 10;
  var RequestedMoveDirection : Real3;
  [Property]
  var MinimumStickThreshold : Real = 0.2;
  [Property]
  var BaseMaxSpeed : Real = 1000;
  var OnGround : Boolean = true;
  [Property]
  var GravityStrength : Real = -10;
  var StickX : Real;
  
  //***************************************************************************
  function Initialize(init : CogInitializer)
  {
    this.IM = this.GameSession.IM;
    Zero.Connect(this.Owner, Events.MovementRequest, this.OnMovementRequest);
    Zero.Connect(this.Space, Events.PhysicsUpdate, this.OnPhysicsUpdate);
  }
  
  //***************************************************************************
  function OnMovementRequest(event : InputEvent)
  {
    this.MoverSpeed += this.Acceleration * event.Magnitude * event.Dt;
    if(event.Magnitude >= this.MinimumStickThreshold)
    {
      this.RequestedMoveDirection = event.RequestedMoveDirection;
    }
    else
    {
      if(this.MoverSpeed >= this.Deceleration * event.Dt)
      {
        this.MoverSpeed -= this.Deceleration * event.Dt;
      }
      else
      {
        this.MoverSpeed = 0;
      }
    }
    if(this.MoverSpeed > this.BaseMaxSpeed)
    {
      this.MoverSpeed = this.BaseMaxSpeed;
    }
    this.StickX = event.StickX;
  }

  //***************************************************************************
  function OnPhysicsUpdate(event : UpdateEvent)
  {
    var newVelocity = this.Orientation.WorldForward * this.MoverSpeed * event.Dt;
    
    //Check collision on our feet to see if we're on the ground
    this.OnGround = false;
    var contacts = this.Owner.Collider.Contacts;
    foreach(var contactPoint in contacts)
    {
      if(contactPoint.FirstPoint.LocalPoint.Y < -0.44)
      {
        this.OnGround = true;
      }
    }
    //Apply gravity if we're not on the ground
    if(this.OnGround)
    {
      //newVelocity.Y = 0;
    }
    else
    {
      newVelocity.Y += this.GravityStrength * event.Dt;
    }
    //Final application of velocity to the rigidbody. ONLY DO THIS ONCE PER FRAME
    this.RigidBody.Velocity = newVelocity;

    
    //Turn toward the direction the stick is pointing relative to the camera
    var sweepResults = this.Space.PhysicsSpace.SweepCollider(this.Owner.Collider, Real3(0, -0.5, 0), event.Dt, CastFilter());
    var groundNormal = Real3.Zero;
    if(sweepResults.IsNotEmpty)
    {
      var contactCounter = 0;
      foreach(var result in sweepResults)
      {
        groundNormal += result.WorldNormalTowardsSelf;
        ++contactCounter;
      }
      groundNormal /= contactCounter;
    }
    
    var ray = Ray(this.Owner.Transform.Translation, Real3(0, -1, 0));
    var result = this.Space.PhysicsSpace.CastRayFirst(ray);
    Print(this.OnGround);
    var newRight = Math.Normalize(Math.Cross(result.Normal, this.Orientation.WorldForward));
    
    
    var newForward = Math.Cross(newRight, result.Normal);
    var requestedMoveDirection = this.RequestedMoveDirection;
    requestedMoveDirection.X *= -1;
    
    this.Orientation.LookAtDirectionWithUp(newForward, result.Normal);
    var targetForward = Math.Cross(this.RequestedMoveDirection, result.Normal);
    targetForward = Math.Cross(targetForward, result.Normal);
    this.Orientation.LookAtDirectionWithUp(Math.RotateTowards(this.Orientation.WorldForward, targetForward, this.TurnSpeed * event.Dt), result.Normal);
  }
}
